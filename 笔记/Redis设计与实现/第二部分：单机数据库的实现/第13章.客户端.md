# 客户端
通过使用由I/O复用技术实现的文件事件处理器，redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。

对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的 redis.h/redisClient 结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：

- 客户端的套接字描述符
- 客户端名字
- 客户端的标志值
- 指向客户端正在使用的数据库的指针，以及该数据库的号码
- 客户端当前要执行的命令，命令的参数，参数的个数，以及指向客户端命令实现函数的指针
- 客户端的输入缓冲区和输出缓冲区
- 客户端的复制状态信息，以及进行复制需要的数据结构。
- 客户端执行BRPOP， BLPOP等列表阻塞命令时所使用的数据结构
- 客户端的事务状态，以及执行watch命令时用到的数据结构
- 客户端执行发布与订阅功能时用到的数据结构
- 客户端的身份验证标志
- 客户端的创建时间，客户端与服务器最后一次通信时间，以及客户端的输出缓冲区大小超出软性限制的时间

```c
struct redisServer {
    // ...
    // 一个链表，保存了所有的客户端状态
    list *clients
    // ...
}
```

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594256222_20200709083755316_1031523188.png)

## 客户端属性
客户端状态包含的属性可以分两类：
- 一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性
- 另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行watch命令时需要用到的watched_keys属性等等

### 套接字描述符
客户端状态的fd属性记录了客户端正在使用的套接字描述符：

```c
typedef struct redisClient {
    // ...
    int fd;
    // ...
} redisClient
```

根据客户端类型的不同，fd属性的值可以是-1或大于-1的整数
- 伪客户端的fd属性是-1；伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字链接，自然也就不需要记录套接字描述符。目前redis在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的redis命令。
- 普通客户端的fd属性的值大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。

### 名字

```c
typedef struct redisClient {
    // ...
    robj *name;
    // ...
} redisClient
```
在默认情况下，一个链接到服务器的客户端是没有名字的。
使用client setname命令可以为客户端设置一个名字，让客户端身份变的更清晰。

### 标志
客户端的标志属性 flags 记录了客户端的角色（role）， 以及客户端目前所处的状态：
```c
typedef struct redisClient {

    // ...

    int flags;

    // ...

} redisClient;
```
flags 属性的值可以是单个标志：

flags = <flag>
也可以是多个标志的二进制或， 比如：

flags = <flag1> | <flag2> | ...
每个标志使用一个常量表示， 一部分标志记录了客户端的角色：
- 在主从服务器进行复制操作时， 主服务器会成为从服务器的客户端， 而从服务器也会成为主服务器的客户端。 REDIS_MASTER 标志表示客户端代表的是一个主服务器， REDIS_SLAVE 标志表示客户端代表的是一个从服务器。
- REDIS_PRE_PSYNC 标志表示客户端代表的是一个版本低于 Redis 2.8 的从服务器， 主服务器不能使用 PSYNC 命令与这个从服务器进行同步。 这个标志只能在 REDIS_SLAVE 标志处于打开状态时使用。
- REDIS_LUA_CLIENT 标识表示客户端是专门用于处理 Lua 脚本里面包含的 Redis 命令的伪客户端。

而另外一部分标志则记录了客户端目前所处的状态：

- REDIS_MONITOR 标志表示客户端正在执行 MONITOR 命令。
- REDIS_UNIX_SOCKET 标志表示服务器使用 UNIX 套接字来连接客户端。
- REDIS_BLOCKED 标志表示客户端正在被 BRPOP 、 BLPOP 等命令阻塞。
- REDIS_UNBLOCKED 标志表示客户端已经从 REDIS_BLOCKED 标志所表示的阻塞状态中脱离出来， 不再阻塞。 REDIS_UNBLOCKED 标志只能在 REDIS_BLOCKED 标志已经打开的情况下使用。
- REDIS_MULTI 标志表示客户端正在执行事务。
- REDIS_DIRTY_CAS 标志表示事务使用 WATCH 命令监视的数据库键已经被修改， REDIS_DIRTY_EXEC 标志表示事务在命令入队时出现了错误， 以上两个标志都表示事务的安全性已经被破坏， 只要这两个标记中的任意一个被打开， EXEC 命令必然会执行失败。 这两个标志只能在客户端打开了 REDIS_MULTI 标志的情况下使用。
- REDIS_CLOSE_ASAP 标志表示客户端的输出缓冲区大小超出了服务器允许的范围， 服务器会在下一次执行 serverCron 函数时关闭这个客户端， 以免服务器的稳定性受到这个客户端影响。 积存在输出缓冲区中的所有内容会直接被释放， 不会返回给客户端。
- REDIS_CLOSE_AFTER_REPLY 标志表示有用户对这个客户端执行了 CLIENT_KILL 命令， 或者客户端发送给服务器的命令请求中包含了错误的协议内容。 服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端， 然后关闭客户端。
- REDIS_ASKING 标志表示客户端向集群节点（运行在集群模式下的服务器）发送了 ASKING 命令。
- REDIS_FORCE_AOF 标志强制服务器将当前执行的命令写入到 AOF 文件里面， REDIS_FORCE_REPL 标志强制主服务器将当前执行的命令复制给所有从服务器。 执行 PUBSUB 命令会使客户端打开 REDIS_FORCE_AOF 标志， 执行 SCRIPT_LOAD 命令会使客户端打开 REDIS_FORCE_AOF 标志和 REDIS_FORCE_REPL 标志。
- 在主从服务器进行命令传播期间， 从服务器需要向主服务器发送 REPLICATION ACK 命令， 在发送这个命令之前， 从服务器必须打开主服务器对应的客户端的 REDIS_MASTER_FORCE_REPLY 标志， 否则发送操作会被拒绝执行。

### 输入缓冲区
客户端状态的输入缓冲区用于保存客户端发送的命令请求：

```c
typedef struct redisClient {

    // ...

    sds querybuf;

    // ...

} redisClient;
```

举个例子， 如果客户端向服务器发送了以下命令请求：

```
SET key value
```
那么客户端状态的 querybuf 属性将是一个包含以下内容的 SDS 值：

```
*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n
```


![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594256222_20200709085201966_174738485.png)

输入缓冲区的大小会根据输入内容动态地缩小或者扩大， 但它的最大大小不能超过 1 GB ， 否则服务器将关闭这个客户端。

### 命令与命令参数
在服务器将客户端发送的命令请求保存到客户端状态的 querybuf 属性之后， 服务器将对命令请求的内容进行分析， 并将得出的命令参数以及命令参数的个数分别保存到客户端状态的 argv 属性和 argc 属性：
```c
typedef struct redisClient {

    // ...

    robj **argv;

    int argc;

    // ...

} redisClient;
```
argv 属性是一个数组， 数组中的每个项都是一个字符串对象： 其中 argv[0] 是要执行的命令， 而之后的其他项则是传给命令的参数。

argc 属性则负责记录 argv 数组的长度。


举个例子， 对于图 13-4 所示的 querybuf 属性来说， 服务器将分析并创建图 13-5 所示的 argv 属性和 argc 属性。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594256223_20200709085245229_1219571946.png)

### 命令的实现函数
当服务器从协议内容中分析并得出 argv 属性和 argc 属性的值之后， 服务器将根据项 argv[0] 的值， 在命令表中查找命令所对应的命令实现函数。
![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594256223_20200709085258217_1761769454.png)

图 13-6 展示了一个命令表示例， 该表是一个字典， 字典的键是一个 SDS 结构， 保存了命令的名字， 字典的值是命令所对应的 redisCommand 结构， 这个结构保存了命令的实现函数、 命令的标志、 命令应该给定的参数个数、 命令的总执行次数和总消耗时长等统计信息。

当程序在命令表中成功找到 argv[0] 所对应的 redisCommand 结构时， 它会将客户端状态的 cmd 指针指向这个结构：

typedef struct redisClient {

    // ...

    struct redisCommand *cmd;

    // ...

} redisClient;
之后， 服务器就可以使用 cmd 属性所指向的 redisCommand 结构， 以及 argv 、 argc 属性中保存的命令参数信息， 调用命令实现函数， 执行客户端指定的命令。

图 13-7 演示了服务器在 argv[0] 为 "SET" 时， 查找命令表并将客户端状态的 cmd 指针指向目标 redisCommand 结构的整个过程。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594256223_20200709085315391_554688542.png)

针对命令表的查找操作不区分输入字母的大小写， 所以无论 argv[0] 是 "SET" 、 "set" 、或者 "SeT ， 等等， 查找的结果都是相同的。


### 输出缓冲区
执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面， 每个客户端都有两个输出缓冲区可用， 一个缓冲区的大小是固定的， 另一个缓冲区的大小是可变的：

固定大小的缓冲区用于保存那些长度比较小的回复， 比如 OK 、简短的字符串值、整数值、错误回复，等等。
可变大小的缓冲区用于保存那些长度比较大的回复， 比如一个非常长的字符串值， 一个由很多项组成的列表， 一个包含了很多元素的集合， 等等。
客户端的固定大小缓冲区由 buf 和 bufpos 两个属性组成：

```c
typedef struct redisClient {

    // ...

    char buf[REDIS_REPLY_CHUNK_BYTES];

    int bufpos;

    // ...

} redisClient;
```

buf 是一个大小为 REDIS_REPLY_CHUNK_BYTES 字节的字节数组， 而 bufpos 属性则记录了 buf 数组目前已使用的字节数量。

REDIS_REPLY_CHUNK_BYTES 常量目前的默认值为 16*1024 ， 也即是说， buf 数组的默认大小为 16 KB 。

图 13-8 展示了一个使用固定大小缓冲区来保存返回值 +OK\r\n 的例子。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594256224_20200709085350862_423813767.png)

当 buf 数组的空间已经用完， 或者回复因为太大而没办法放进 buf 数组里面时， 服务器就会开始使用可变大小缓冲区。

可变大小缓冲区由 reply 链表和一个或多个字符串对象组成：

```c
typedef struct redisClient {

    // ...

    list *reply;

    // ...

} redisClient;
```
通过使用链表来连接多个字符串对象， 服务器可以为客户端保存一个非常长的命令回复， 而不必受到固定大小缓冲区 16 KB 大小的限制。

图 13-9 展示了一个包含三个字符串对象的 reply 链表。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594256224_20200709085421154_1982208517.png)

### 身份验证
客户端状态的 authenticated 属性用于记录客户端是否通过了身份验证：
```c
typedef struct redisClient {

    // ...

    int authenticated;

    // ...

} redisClient;
```
如果 authenticated 的值为 0 ， 那么表示客户端未通过身份验证； 如果 authenticated 的值为 1 ， 那么表示客户端已经通过了身份验证。

举个例子， 对于一个尚未进行身份验证的客户端来说， 客户端状态的 authenticated 属性将如图 13-10 所示。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594256224_20200709085446484_1064729308.png)

当客户端 authenticated 属性的值为 0 时， 除了 AUTH 命令之外， 客户端发送的所有其他命令都会被服务器拒绝执行：

```redis
redis> PING
(error) NOAUTH Authentication required.

redis> SET msg "hello world"
(error) NOAUTH Authentication required.
```

authenticated 属性仅在服务器启用了身份验证功能时使用： 如果服务器没有启用身份验证功能的话， 那么即使 authenticated 属性的值为 0 （这是默认值）， 服务器也不会拒绝执行客户端发送的命令请求。

## 重点回顾
- 服务器状态结构使用 clients 链表连接起多个客户端状态， 新添加的客户端状态会被放到链表的末尾。
- 客户端状态的 flags 属性使用不同标志来表示客户端的角色， 以及客户端当前所处的状态。
- 输入缓冲区记录了客户端发送的命令请求， 这个缓冲区的大小不能超过 1 GB 。
- 命令的参数和参数个数会被记录在客户端状态的 argv 和 argc 属性里面， 而 cmd 属性则记录了客户端要执行命令的实现函数。
- 客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用， 其中固定大小缓冲区的最大大小为 16 KB ， 而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。
- 输出缓冲区限制值有两种， 如果输出缓冲区的大小超过了服务器设置的硬性限制， 那么客户端会被立即关闭； 除此之外， 如果客户端在一定时间内， 一直超过服务器设置的软性限制， 那么客户端也会被关闭。
- 当一个客户端通过网络连接连上服务器时， 服务器会为这个客户端创建相应的客户端状态。 网络连接关闭、 发送了不合协议格式的命令请求、 成为 CLIENT_KILL 命令的目标、 空转时间超时、 输出缓冲区的大小超出限制， 以上这些原因都会造成客户端被关闭。
- 处理 Lua 脚本的伪客户端在服务器初始化时创建， 这个客户端会一直存在， 直到服务器关闭。
- 载入 AOF 文件时使用的伪客户端在载入工作开始时动态创建， 载入工作完毕之后关闭。
