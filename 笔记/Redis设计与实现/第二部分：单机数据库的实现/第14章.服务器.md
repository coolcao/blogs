# 服务器
## 初始化服务器
一个redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。

### 初始化服务器状态结构
初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。

初始化server变量的工作由 redis.c/initServerConfig 函数完成，以下是 initServerConfig 函数完成的主要工作：
- 设置服务器的运行ID
- 设置服务器的默认运行频率。
- 设置服务器的默认配置文件路径。
- 设置服务器的运行架构
- 设置服务器的默认端口号
- 设置服务器的默认RDB持久化条件和AOF持久化条件
- 初始化服务器的LRU时钟
- 创建命令表

### 载入配置选项

服务器在用 initServerConfig函数初始化完成server变量之后，就会开始载入用户给定的配置参数和配置文件，并根据用户设定的配置，对server变量相关属性的值进行修改。

我们可以通过给定配置参数的方式，修改服务器配置，比如：

```
redis-server --port 10086
```
修改服务器端口。

也可以在配置文件中修改默认配置。

```
# 将服务器的数据库数量设置为32个
databases 32
# 关闭RDB 文件的压缩功能
rdbcompression no
```

### 初始化服务器数据结构
在之前执行initServerConfig函数初始化server状态时，程序只命令表一个数据结构，不过除了命令之外，服务器状态还包含其他数据结构，比如：
- server.clients链表，这个链表记录了所有与服务器相连的客户端状态结构，链表的每一个节点保存了redisClient结构实例
- 用于保存频道订阅信息的 server.pubsub_channels字典，以及用于保存模式订阅信息的 server.pubsub_patterns链表
- server.db数组，数组中包含了服务器的所有数据库
- 用于执行Lua脚本的Lua环境 server.lua
- 用于保存慢查询日志的 server.slowlog属性

除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括：
1. 为服务器设置进程信号处理器
2. 创建共享对象，这些对象包含redis服务器经常用到的一些值，比如包含OK回复的字符串对象，包含ERR回复的字符串对象，包含1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。
3. 打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。
4. 为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数
5. 如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做准备。
6. 初始化服务器的I/O模块，为将来的I/O操作做好准备。

当initServer函数执行完毕后，服务器将用ASCII 字符在日志中打印出Redis图标，以及Redis的版本号信息。


### 还原数据库状态
在完成了对服务器的初始化后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。

根据是否启用了AOF持久化，服务器载入数据时所用的目标文件会有所不同：
- 如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。
- 相反地，如果服务器没用启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。

当服务器完成数据库状态还原工作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费的时长。


## 命令请求的执行过程
一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。
如果我们使用客户端执行以下命令：

```
redis> set key value
OK
```

那么从客户端发送 set key value 命令到获得回复OK期间，客户端和服务器共需要执行以下操作：
1. 客户端向服务器发送命令请求 set key value。
2. 服务器接收并处理客户端发来的命令请求 set key value，在数据库中进行设置操作，并产生回复OK
3. 服务器将命令回复OK发送给客户端。
4. 客户端接收服务器返回的命令回复OK，并将这个回复打印给用户观看

### 发送命令请求
redis服务器的命令请求来自redis客户端，当用户在客户端键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。

```
              键入命令请求                           将命令请求转换成协议格式然后发送
用户 -----------------------> 客户端 --------------------------------------------------------> 服务器
```

### 读取命令请求
当客户端与服务器之间的链接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：
1. 读取套接字中的协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面
2. 对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面
3. 调用命令执行器，执行客户端指定的命令

### 命令执行器（1）:查找命令实现
命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。

命令表是一个字典，字典的键是一个个命令名字，比如 set, get, del等，而字典的值是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1595550876_20200724080236589_2075487315.png)

### 命令执行器（2）:执行预备操作
到目前为止，服务器已经将执行命令所需的命令实现函数，参数，参数个数都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确，顺利的执行，这些预备操作包括：
- 检查客户端状态的cmd指针是否指向null，如果是的话，那么说明用户输入的命令名字找不到对应的命令实现，服务器不再执行后续操作，并向客户端返回一个错误
- 根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续操作，直接向客户端返回一个错误。
- 检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行auth命令，如果未通过身份验证的客户端试图执行其他命令，那么服务器将返回一个错误
- 如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续操作，并向客户端返回一个错误。
- 如果服务器上一次执行bgsave命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。
- 如果客户端当前正在用subscribe命令订阅频道，或者正在用psubscribe命令订阅模式，那么服务器只会执行客户端发来的subscribe, psubscribe, unsubscribe, punsubscribe四个命令，其他命令都会被拒绝。
- 如果服务器正在进行数据载入，那么客户端发送的命令必须带有1标识才会被服务器执行，其他命令都会被服务器拒绝。
- 如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的shutdown nosave命令和 script kill命令，其他命令都会被服务器拒绝。
- 如果客户端正在执行事务，那么服务器只会执行客户端发来的exec, discard, multi, watch四个命令，其他命令都会被放进事务队列中。
- 如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。

当完成以上预备操作后，服务器就可以真正执行命令了。


### 命令执行器（3）:调用命令的执行函数

### 命令执行器（4）:执行后续工作
- 如果服务器开启了慢查询日志，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志
- 根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增1
- 如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区
- 如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。

### 将命令回复发送给客户端

### 客户端接受并打印命令回复

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1595550877_20200724082243667_1138424984.png)

## serverCron 函数
Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。

### 更新服务器的时间缓存
redis有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存。

```c
struct redisServer {
    // ...
    // 保存了秒级精度的系统当前unix时间戳
    time_t unixtime;

    // 保存了毫秒级精度的系统当前unix时间戳
    long long mstime;

    // ...
}
```

因为serverCron函数默认以100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精度并不高。

### 更新LRU时钟
服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性，mstime属性一样，都是服务器时间缓存的一种；

每隔redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间。

当服务器要计算一个数据库键的空转时间，程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间，得出的结果就是这个对象的空转时间。

### 更新服务器每秒执行命令次数

### 更新服务器内存峰值记录

### 处理SIGTERM信号

### 管理客户端资源

### 管理数据库资源

### 执行被延迟的BGREWRITEAOF

### 检查持久化操作的运行状态

### 将AOF缓冲区的内容写入AOF文件

### 关闭异步客户端

### 增加cronloops计数器的值