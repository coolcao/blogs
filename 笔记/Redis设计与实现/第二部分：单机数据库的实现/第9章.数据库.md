# 数据库

## 服务器中的数据库
Redis服务器将所有数据库都保存在服务器状态 redis.h/redisServer 结构的db数组中，db数组的每个项都是一个 redis.h/redisDb结构，每个redisDb结构代表一个数据库：

```c
struct redisServer {
    //...
    // 一个数组，保存着服务器中的所有数据库
    redisDb *db;
    //服务器中的数据库数量
    int dbnum;
}
```

dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16.所以Redis服务器默认会创建16个数据库，如图所示：

![graphviz-6d5a23554720addffde00d34f9f6212498203291](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1593873642_20200704214512773_1668325054.png)

## 切换数据库
每个redis客户端都有自己的目标数据库，每当客户端执行数据库读写命令时，目标数据库就会称为这些命令的操作对象。

默认情况下，redis客户端的目标数据库为0号数据库，但客户端可以通过执行 select 命令来切换目标数据库。

在服务器内部，客户端状态 redisClient 结构的db属性记录了客户端当前的目标数据库，这个属性是一个只想 redisDb结构的指针：

```c
typedef struct redisClient{
    //...
    // 记录客户端当前正在使用的数据库
    redisDb *db
    //...
} redisClient;
```

redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。

比如说，如果某个客户端的目标数据库为1号数据库，那么这个客户端所对应的状态和服务器之间的关系如图：

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1593873642_20200704221247338_2124970358.png)

如果这时客户端执行命令 select 2，将目标数据库改为2号数据库，那么客户端状态和服务器之前的关系将变为：

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1593873643_20200704221400634_756577556.png)

> **谨慎处理多数据库程序**
> 
> 到目前为止，Redis仍然没有可以返回客户端目标数据库的命令。虽然有的客户端会在输入符号边提示当前所使用的目标数据库:
> ```redis
> redis> select 1
> OK
> redis[1]> select 2
> OK
> redis[2]>
> ```
> 但如果你在其他语言的客户端中执行redis命令，并且该客户端没有像redis-cli那样一直显示目标数据库的号码，那么在数次切换数据库之后，你很可能忘记自己当前正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执行redis命令时，特别是像 flushdb 这样危险命令之前，最好先执行一下 select 命令，显式切换到指定数据库，然后再执行别的命令。

## 数据库键空间
redis是一个键值对数据库服务器，服务器中的每个数据库都由一个 redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间：

```c
typedef struct redisDb {
    // ...
    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;
    //...
} redisDb;
```

键空间和用户所见的数据库是直接对应的：
- 键空间的键，也就是数据库的键，每个键都是一个字符串对象
- 键空间的值也就是数据库的值，每个值可以是字符串对象，列表对象，哈希表对象，集合对象和有序集合对象中的任意一种redis对象。

```redis
redis> set message "hello world"
OK

redis> rpush alphabet "a" "b" "c"
(integer) 3

redis> hset book name "redis in action"
(integer) 1

redis> hset book author "Josiah L. Carlson"
(integer) 1

redis> hset book publisher "Manning"
(integer) 1

```

那么在执行完这些命令后，数据库的键空间如图所示：

![graphviz-b1bea528da9b180dc035546f23f8956a242fc0f5](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1593873643_20200704222546263_986801235.png)

### 添加新键
添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典，其中键为字符串对象，而值则为任意一种类型的redis对象。

### 删除键
删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。

### 更新键
对一个数据库键进行更新，实际上就是对键空间里面所对应的值对象进行更新，根据对象的类型不同，更新的具体方法也会有所不同。

### 对键取值
对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。

### 读写键空间时的维护操作
当使用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：

- 在读取一个键后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数。这两个值可以在 info stats 命令的 keyspace_hits属性和keyspace_misses属性中查看。
- 在读取一个键后，服务器会更新键的LRU（最后一次使用）时间，这个值可用于计算键的空闲时间，使用 `object idletime <key>`命令查看键key的闲置时间。
- 如果服务器在读取一个键时发现已经过期，那么服务器会先删除这个过期键，然后才执行余下的操作。
- 如果客户端使用watch命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏，从而让事务程序注意到这个键已经被修改过。
- 服务器每次修改一个键之后，都会对脏键计数器的值增1，这个计数器会触发服务器的持久化操作以及复制操作。
- 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。


## 设置键的生存时间或过期时间
通过 EXPIRE 命令或者 PEXPRIE 命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time to live, TTL），在经过指定的秒数或毫秒数之后，服务器就会自动删除生存时间为0的键。

```redis
redis> set key value
OK

redis> expire key 5

redis> get key    // 5s之内
"value"

redis> get key    // 5s之后
(nil)
```

> **注意**
> setex 命令可以在设置一个字符串键的同时为键设置过期时间，因为这个命令是一个类型限定命令（只能用于字符串键），所以本章不会对这个命令进行介绍。

和 EXPIRE 命令和 PEXPIRE 命令类似，客户端可以通过 EXPIREAT 命令或  PEXPIREAT 命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time），过期时间是一个unix时间戳，当键的过期时间来临，服务器就会自动从数据库中删除这个键。

```redis
redis> set key value
OK

redis> expireat key 1377257300
(integer) 1

redis> time
1) "1377257296"
2) "296543"

redis> get key    // 1377257300之前
"value"

redis> time
1) "1377257303"
2) "296543"

redis> get key     // 1377257300之后
(nil)
```

TTI命和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键剩余生存时间，也就是返回距离这个键被服务器自动删除还有多长时间。


### 设置过期时间
redis有四个不同的命令可以用于设置键的生存时间或过期时间。

- expire <key> <ttl>命令用于将键key的生存时间设置为ttl秒
- pexpire <key> <ttl>命令用于将键key的生存时间设置为ttl毫秒
- expireat <key> <timestamp> 命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳
- pexpireat <key> <timestamp> 命令用于将键key的过期时间设置为timestamp所指定的毫秒时间戳

### 保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：
- 过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）
- 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间-->一个毫秒精度的unix时间戳

```c
typedef struct redisDb {
    // ...
    // 过期字典，保存着键的过期时间
    dict *expires;
} redisDb;
```

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1593998930_20200706084757785_41688918.png)

> 为方便展示，图9-12的键空间和过期字典中重复出现了两次alphabet键对象和book键对象。在实际中，键空间的键和过期字典的键都指向同一个键对象，所以不会出现任何重复对象，也不存在任何浪费。

### 移除过期时间
persist命令可以移除一个键的过期时间。
persist命令就是pexpireat命令的反操作，在过期时间字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。

### 计算并返回剩余 生存时间
ttl命令以秒为单位返回键的剩余生存时间，而pttl命令则以毫秒为单位返回键的剩余生存时间。两个命令都是通过计算键的过期时间和当前时间之间的差来实现的。


### 过期键的判定
通过过期字典，程序可以用以下步骤检查一个给定的键是否过期：
1. 检查给定键是否存在与过期字典，如果存在，那么取得键的过期时间
2. 检查当前unix时间戳是否大于键的过期时间，如果是的话，那么键已经过期，负责，键未过期。

> 另一种使用ttl命令或者pttl命令，比如说，如果某个键执行ttl命令，并且返回的值大于等于0，那么说明该键未过期，在实际中，redis检查键是否过期的方法和is_expired函数所描述的方法一直，因为直接访问字典比执行一个命令稍微快一些。

## 过期键删除策略
- 定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
- 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键。
- 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

### 定时删除
定时删除是对内存最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快的删除，并释放过期键所占用的内存。
缺点是，他对CPU时间是最不友好的。在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑对服务器的响应时间和吞吐量造成影响。

### 惰性删除
惰性删除对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查。这可以保证删除过期键只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。
缺点是，他对内存最不友好，如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。

### 定期删除
定期删除是前两中策略的一种整合和折中：
- 定期删除策略每隔一段时间执行删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
- 除此之外，通过定期删除过期键，定期删除策略有效的减少了因为过期键带来的内存浪费。

定期删除的难点是确定删除操作执行的时长和频率：
1. 如果删除操作执行的太频繁，或者执行时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多的消耗在删除定期键上面。
2. 如果删除操作执行的太少或者执行时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。
因此，如果采用定期删除策略的话，服务器必须根据情况，合理的设置删除操作的执行时间和执行频率。

## redis的过期键删除策略
redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好的在合理使用CPU时间和避免浪费内存空间之间取得平衡。

### 惰性删除策略的实现
过期键的惰性删除测吕有 db.c/expireIfNeeded 函数实现，所有读写数据库的redis命令在执行之前都会调用 expireIfNeeded 函数对输入键进行检查：
- 如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除
- 如果输入键未过期，那么expireIfNeeded函数不做动作。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1593998931_20200706092120133_585975904.png)

因为每隔被访问的键都可能因为过期而被expireIfNeeded函数删除，所以每隔命令的实现函数都必须能同时处理键存在以及不存在两种情况。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1593998931_20200706092246877_137013386.png)

### 定期删除策略的实现
定期删除策略由 redis.c/activeExpireCycle 函数实现，每当redis的服务器周期性操作 redis.c/serverCron 函数执行时，activeExpireCycle函数就会被调用，他在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。

- 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键
- 全局变量 current_db 会记录当前activeExpireCycle函数检查的进度。比如当前activeExpireCycle函数在遍历10号数据库时返回了，那么下载熬提着ExpireCycle函数执行时，将从11号数据库开始查找并删除过期键
- 随着熬提着ExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。


## AOF, RDB和复制功能对过期键的处理
### 生成RDB文件
在执行save或bgsave命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

数据库中的过期键不会对生成新的RDB文件造成影响。

### 载入RDB文件
在启动redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：
- 如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。
- 如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。

### AOF文件写入
当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或定期删除，那么AOF文件不会因为这个过期键而产生任何影响。
当过期键被惰性删除或定期删除后，程序会向AOF文件追加一条DEL命令，来显式的记录该键已被删除。

### AOF重写
和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。

### 复制
当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制：
- 主服务器在删除一个过期键后，会显式的向所有从服务器发送一个DEL命令，通知从服务器删除这个过期键
- 从服务器在执行客户端的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期键一样来处理过期键。
- 从服务器只有在接到主服务器发送来的DEL命令后，才会删除过期键。

通过由主服务器控制从服务器统一的删除过期键，可以保证主从服务器的数据一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制也会继续存在。

![graphviz-6e917ce52dd6b7229798347a6a0c7b271b6346ae](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594044590_20200706220825904_178846569.png)

![graphviz-9839089a12e44ba12c2237a4c250bfe0e004e15b](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594044590_20200706220835947_659319185.png)

![graphviz-763e7edad215846a6cf6a99999eeace75f99d5de](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594044590_20200706220844877_259737168.png)

![graphviz-bb687147c3aba0b825b951326887947d07d53624](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1594044590_20200706220858567_1675052209.png)

## 重点回顾
- Redis服务器的所有数据库都保存在 redisServer.db 数组中，而数据库的数量则由 redisServer.dbnum 属性保存
- 客户端通过修改目标数据库指针，让他指向 redisServer.db 数组中的不同元素来切换不同的数据库
- 数据库主要由 dict 和 expires 两个字典构成，其中 dict 字典负责保存键值对，而expires 字典则负责保存键的过期时间
- 因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。
- 数据库的键总是一个字符串对象，而值则可以式任意一种redis对象类型，包括字符串对象，哈希表对象，集合对象，列表对象和有序集合对象，分别对应字符串键，哈希表键，集合键，列表键，和有序集合键
- expires 字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间时一个以毫秒为单位的unix时间戳
- redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。
- 执行save命令或者bgsave命令所产生的新RDB文件不会包含已经过期的键
- 当一个过期键被删除后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式的删除过期键。
- 当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显示的删除过期键。
- 从服务器即使发现过期键也不会自作主张的删除它，而是等待主节点发来DEL命令，这种统一，中心化的过期键删除策略可以保证主从服务器数据的一致性。
- 当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。