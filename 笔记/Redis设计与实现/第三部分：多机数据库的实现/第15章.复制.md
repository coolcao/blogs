# 复制
在Redis中，可以通过SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，我们称被复制的服务器为主服务器(master)，而对主服务器进行复制的服务器则被称为从服务器(slave)。

## 旧版复制功能的实现
Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：
- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态
- 命令传播操作则用于在主服务器的数据库状态发生改变时，导致主从服务器的数据库状态出现不一致，让主从服务器的数据库状态重新回到一致状态

### 同步
当客户端向从服务器发送slaveof命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。

从服务器对主服务器的同步操作，需要通过向主服务器发送sync命令来完成。

1. 从服务器向主服务器发送sync命令
2. 收到sync命令的主服务器执行bgsave命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
3. 当主服务器的bgsave命令执行完毕时，主服务器会将bgsave命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行bgsave命令时的数据库状态。
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

### 命令传播
在同步操作执行完毕后，主从服务器两者的数据库状态将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库状态有可能会被修改的，并导致主从服务器状态不再一致。

为了让主从服务器再次回到一致，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的命令，就是造成主从服务器不一致的那条命令，发送给从服务器执行，当从服务器执行了相同的命令之后，主从服务器将再次回到一致状态。

## 旧版复制功能的缺陷
在redis2.8之前，从服务器对主服务器的复制分为以下两种情况：
1. 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。
2. 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连连上了主服务器，并继续复制主服务器。
对于初次复制来说，旧版的复制能够很好的完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却很低。

因为复制时主服务器会将当前数据库状态所有数据生成RDB文件并发送给从服务器载入，但从服务器其实在断线之前已经复制了一部分数据，这部分数据和重连后的RDB文件内有重复，按理说，这部分数据其实是不需要再复制的。

> **sync命令是一个非常耗时的操作**
> 每次执行sync命令，主从服务器需要执行以下动作：
> 1. 主服务器需要执行bgsave来生成RDB文件，这个生成操作会耗费主服务器大量的CPU，内存和磁盘I/O资源。
> 2. 主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源，并对主从服务器响应命令请求的时间产生影响。
> 3. 接收到RDB文件的从服务器需要载入主服务器发送来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。

## 新版复制功能的实现
redis从2.8开始，使用psync命令代替sync命令来执行复制时的同步操作。
psync命令具有完整的重同步(full resynchronization)和部分重同步(partial resynchronization)两种模式：
- 其中完整重同步用于处理初次复制情况，完整重同步的执行步骤和sync命令的执行步骤基本一样，他们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
- 而部分重同步则用于处理断线后的重复制情况，当从服务器在断线后重新链接主服务器时，如果条件允许，主服务器可以将主从服务器链接断开期间执行的写命令发送给从服务器，从服务器只要接收到并执行这些命令，就可以将数据库更新至主服务器当前所处的状态。

psync命令的部分重同步模式解决了旧版复制功能在处理断线后重复复制时出现的低效情况。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1595810279_20200727081543416_990553694.png)

## 部分重同步的实现
部分重同步功能由以下三部分构成：
1. 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量
2. 主服务器的复制积压缓冲区（replication backlog）
3. 服务器的运行ID（run ID）

### 复制偏移量
执行复制的双方，主服务器和从服务器会分别维护一个复制偏移量：
- 主服务器每次向从服务器传播N个字节的时候，就将自己的复制偏移量的值加上N
- 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N

通过对比主从服务器的复制偏移量，程序可以很容易的知道主从服务器是否处于一致状态：
- 如果主从服务器状态一致，那么主从服务器两者的偏移量总是相同的
- 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。

### 复制积压缓冲区
复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列，默认大小为1M。

当主服务器进行命令传播时，它不仅会将命令发送给所有从服务器，还会将命令写入到复制积压缓冲区。

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1595810279_20200727081457085_412766272.png)

因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。


当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：
- 如果offset偏移量之后的数据（也就是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作
- 如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重不同操作。

### 服务器运行ID
除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID：
- 每个redis服务器，不论主服务器还是从服务器，都会有自己的运行ID
- 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成。

当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，从服务器将这个运行ID保存起来。

当从服务器断线并连上一个主服务器时，从服务器将向当前链接的主服务器发送之前保存的运行ID：
- 如果从服务器保存的运行ID和当前链接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作
- 相反，如果从服务器保存的运行ID和当前连接的主服务器的运行ID不同，说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。

## PSYNC命令的实现

![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1595810280_20200727082734582_942703514.png)


## 复制的实现
通过向从服务器发送slaveof命令，我们可以让一个从服务器去复制一个主服务器：

```
slaveof <master_ip> <master_port>
```

### 步骤1:设置主服务器的地址和端口

### 步骤2:建立套接字连接

### 步骤3:发送ping命令

### 步骤4:身份验证

### 步骤5:发送端口信息

### 步骤6:同步

### 步骤7:命令传播

## 心跳检测
在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令，三个作用：

- 检测主从服务器的网络连接状态
- 辅助实现min-slaves选项
- 检测命令丢失

## 重点回顾
- Redis 2.8以前的复制功能不能高效的处理断线后重复复制情况，但Redis2.8新添加的部分重同步功能可以解决这个问题
- 部分重同步通过复制偏移量，复制积压缓冲区，运行ID三个部分来实现
- 在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端
- 主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致。而从服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测。