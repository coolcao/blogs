---
    title: schema与数据类型优化
    date: 2017-07-31
    auther: coolcao
    tags: [mysql]
---

## 选择优化的数据类型
* 更小的通常更好
  尽量使用可以正确存储数据的最小数据类型，但是确保没有低估需要存储的值的范围。
* 简单就好
* 尽量避免Null
  如果*查询*中包含可能为Null的列，对mysql来说更难优化，因为可为Null的列使得索引，索引统计和值比较都更复杂。可为null的列会使用更多的存储空间，在mysql里也需要特殊处理。当可为null的列被索引时，每个索引记录需要一个额外的字节。
  如果计划在列上建索引，就应该尽量避免设计成可为null的列。
  
 > 通常把可为NULL的列改为NOT NULL带来的性能提升比较小，所有（调优时）没必要首先在现有的schema中查找并修改这种情况。**但是，如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列。**

DATETIME和TIMESTAMP列都可以存储相同类型的数据：时间和日期，精确到秒。然而timestamp只使用datetime一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。
另一方面，timestamp允许的时间范围要小很多，有时候它的特殊能力会成为障碍。

### 整数类型
- tinyint		8位
- smallint		16位
- mediumint		24位
- int			32位
- bigint		64位
mysql可以为整数类型指定宽度，例如 int(11)，对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了mysql的一些交互工具（例如mysql命令行客户端）用来显示字符数的个数。**对于存储和计算来说，int(1)和int(20)是相同的。**

### 实数类型
实数类型是带有小数部分的数字。然而他们不只是为了存储小数部分，也可以使用 decimal 存储比 bigint还大的整数。
float,double支持使用标准的浮点运算进行近似计算。
decimal用于存储精确的小数。在mysql 5.0以及更高的版本，decimal支持精确运算。
因为CPU不支持对decimal的直接计算，所以在mysql5.0以及更高版本中，mysql服务器自身对decimal的高精度计算。
浮点和decimal类型都可以指定精度。对于decimal列，可以指定小数点前后所允许的最大位数。
mysql5.0和更高版本将数字打包到一个二进制字符串中（每4个字节存9个数字）。例如，decimal(18,9)小数点两边各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节。
浮点类型在存储同样范围的值时，通常比decimal使用更少的空间。float使用4个字节存储。double使用8个字节存储，相比float有更高的精度和更大的范围。
因为需要额外的空间和计算开销，所以应该尽量只在对小数进行*精确*计算时才使用decimal。例如，存储财务数据。**但是在数据量比较大的时候，可以考虑使用bigint代替decimal，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。**假设要存储财务数据精确到万分之一，则可以把所有金额乘以一百万，然后将结果存储在bigint里，这样可以同时避免浮点存储计算不精确和decimal精确计算代价高的问题。

### 字符串类型
#### varchar
用于存储可变长度字符串。varchar需要使用1或2个额外字节记录字符串的长度。如果列的最大长度小于255字节，则只使用1个字节标识，否则使用2个字节。
下面这些情况下使用varchar是合适的：
* 字符串列的最大长度比平均长度大很多
* 列的更新很少，所以碎片不是问题
* 使用了像utf-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。

#### char
char类型是定长的。
当存储char值时，mysql会**删除所有的末尾空格。char值会根据需要采用空格进行填充以方便比较。**
char适合存储很短的字符串，或者所有值都接近同一个长度。
对于经常变更的数据，char也比varchar更好，因为定长的char类型不容易产生碎片。
对于非常短的列，char比varchar在存储空间上也更有效率。

与char和varchar类似的还有binary和varbinary，他们存储的时二进制字符串。
二进制字符串跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符。填充也不一样，mysql填充binary采用的时 `\0`（零字节）而不是空格，在检索时，也不会去掉填充值。

二进制比较的优势不仅仅体现在大小写敏感上。
mysql比较binary字符串时，每次按一个字节，而且根据该字节的数值进行比较，因此，二进制比较比字符串简单很多，所以也就更快。

#### blob和text类型
blob和text类型都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。
blob存储的时二进制数据，没有排序规则或字符集，而text类型有字符集和排序规则。
与其他类型不同，mysql把每个blob和text值当作一个独立的对象处理，存储引擎在存储时通常会做特殊处理。
当blob和text值太大时，innoDB会使用专门的“外部”存储区进行存储，此时每个值在行内需要 1-4个字节存储一个指针，然后在外部存储区存储实际的值。

### 使用枚举代替字符串类型
mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”。
枚举字段时按照内部存储的整数而不是定义的字符串进行排序的。

枚举最不好的地方时，字符串列表是固定的，添加或删除字符串必须使用alter table。因此，对于一系列未来可能改变的字符串，使用枚举不是一个好主意，除非能接受只在列表末尾添加元素，这样在mysql5.1中就可以 不用重建整个表来完成修改。

### 日期和时间类型
* DATETIME:这个类型能保存大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到格式YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。
* TIMESTAMP:保存从1970年1月1日午夜以来的秒数，它和unix时间戳相同。timestamp只使用4个字节的存储空间，因此它的范围比datetime小得多，只能表示1970年到2038年。timestamp显示的值也依赖时区，mysql服务器，操作系统，以及客户端链接都有时区设置。默认情况下，如果插入时没有指定第一个timestamp列的值，mysql则会甚至这个列的值为当前时间。在插入一行记录时，mysql默认也会更新第一个timestamp列的值，除非在update语句中明确指定了值。timestamp列默认为not null。

除了特殊行为之外，通常也应该尽量使用timestamp，因为它比datetime空间效率更高。
如果需要存储比秒更小粒度的日期和时间怎么办？mysql目前没有提供合适的数据类型，但是可以使用自己的存储格式，可以使用bigint类型存储微秒级别的时间戳，或者使用double存储秒之后的小数部分。或者也可以使用mariadb代替mysql。

### 选择标识符
* 整数类型
整数类型通常时标识列最好的选择，因为它们很快并且可以使用auto_increment。
* 字符串类型
如果可能，应该避免使用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。

如果存储uuid值，则应该移除“-”符号，或者更好的做法是，用 `UNHEX()`函数转换uuid值为16字节的数字，并且存储在一个binary(16)列中，检索时，可以通过 `HEX()` 函数来格式化为十六进制格式。

### 特殊类型数据
对于ipv4地址，人们经常使用varchar(15)来存储ip地址，然而，它们实际上是32位无符号整数，不是字符串。
mysql提供`INET_ATON()`和`INET_NTOA()`函数在这两种表示方法之间转换。

## 加快Alter Table操作的速度
MySQL的Alter Table操作的性能对大表来说是一个问题。
MySQL执行大部分修改表结构的方式是用新的结构创建一个空表，然后从旧表中查出所有数据插入到新表，然后删除旧表。这样操作会花费很长的时间。

一般而言，大部分的Alter Table操作会导致MySQL服务中断。

对常见的场景，能使用的技巧只有两个：
1. 现在一台不服务的机器上执行Alter Table操作，然后和提供服务的主库进行切换。
2. 影子拷贝。影子拷贝的技巧是用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。

不是所有的Alter Table都会引起表重建。
例如有两种方法修改或删除一个列的默认值。
```sql
alter table film 
modify column rental_duration
tinyint(3) not null default 5;
```
这个语句会引起表重建，它会拷贝整张表到新表，甚至列的类型，大小和可否为null属性都没变。

```sql
alter table film
alter column rental_duartion
set default 5;
```
这个语句会直接修改.frm文件，而不涉及表数据。

## 小结
* 尽量避免过度设计，例如会导致及其复杂查询的schema设计，或者有很多列的表设计。
* 使用小而简单的合适数据类型，除非真是数据模型中有确切的需要，否则应该尽可能的避免使用null值。
* 尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列。
* 注意可变长字符串，其在临时表和排序时，可能导致悲观的按最大长度分配内存。
* 尽量使用整形定义标识列
* 避免使用mysql已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度。
* 小心使用enum和set，虽然它们用起来很方便，但是不要滥用，否则有时候会变成陷阱，最好避免使用bit。