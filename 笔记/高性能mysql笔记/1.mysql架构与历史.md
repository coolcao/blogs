---
title: mysql架构与历史
date: 2017-02-04 09:30:02
auther: coolcao
tags: [数据库,mysql]
---

## MySQL逻辑架构
![MySql逻辑架构](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1617153834_20210331092142830_1253484954.png)

* 最上层的服务并不是mysql独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构，比如连接处理，授权认证，安全等。
* 第二层是`mysql`比较有意思的部分。大多数mysql的核心服务功能都在这一层，包括查询解析，分析，优化，缓存以及所有的内置函数，所有的跨存储引擎功能都在这一层实现：存储过程，触发器，视图等。
* 第三层包含了存储引擎。存储引擎负责mysql中数据的存储和提取。

## 并发控制
无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。

在处理并发读或写时，可以通过实现一个由两种类型的索组成的锁系统来解决问题。共享锁和排他锁，也叫读锁和写锁。

读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同事读取同一个资源，而不互相干扰。
写锁是排他的，一个写锁会阻塞其他的写锁和读锁，这时出于安全考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

### 锁粒度
* 表锁：表锁是Mysql里最基本的锁策略，并且是开销最小的策略。它会锁定整张表。
* 行锁：行级锁可以最大程度的支持并发处理，同时也带来了最大的锁开销。在InnoDB中实现了行锁，行锁只在存储引擎中实现，而mysql服务层没有实现。


## 事务
事务就是一组原子性的sql查询，或者说一个独立的工作单元。

* 原子性
    一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。
* 一致性
    数据库总是从一个一致性的状态装换到另外一个一致性的状态。
* 隔离性
    通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
* 持久性
    一旦事务提交，则其所做的修改就会永久的保存到数据库中。

### 隔离级别

1. READ UNCOMMITTED 未提交读
    在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称作脏读。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但确缺乏其他级别的很多好处，除非真的有必要的理由，在实际应用中一般很少使用。
2. READ COMMITED 提交读
    大多数数据库系统的默认隔离级别是 READ COMMITED（但mysql不是）。READ COMMITED满足前面提到的隔离性简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。
3. REPEATABLE READ 可重复写
    MySQL的默认事务隔离级别。
    REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取同样的记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另一个幻读的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。
4. SERIALIZABLE 可串行化
    SERIALIZABLE 是最高的隔离级别。它通过强事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在曲度的每一行数据都加上锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑使用该级别。

### 死锁

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

当多个事务试图以不同的顺序锁定资源时，就可能发生死锁。

InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。

### 事务日志
事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时，只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据持久到磁盘。**事务日志采用追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久化后，内存中被修改的数据可以在后台漫漫地刷回磁盘。** 目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志，修改数据刷要写两次磁盘。

如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

## 多版本并发控制(MVCC)
InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存列行的过期时间（或过期时间）。

## mysql的存储引擎

### InnoDB存储引擎

InnoDB是mysql的默认事务型引擎，也是最重要，使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况是正常提交的，很少被回滚。
InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。
除非非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。

#### InnoDB概览

InnoDB的数据存储在表空间（tablespace）中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。
InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认是 REPEATABLE READ(可重复读写)，并且通过间隙锁（next key locking）策略防止幻读的出现。

### MyISAM存储引擎

MyISAM提供了大量的特性，包括全文索引，压缩，空间函数（GIS），但 **MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。**

尽管MyISAM引擎不支持事务，不支持崩溃后的安全恢复，但它绝不是一无是处，对于只读的数据，或者表比较小，可以忍受修复操作，则依然可以继续使用MyISAM。（但请不要默认使用MyISAM，而是默认使用InnoDB）。

#### 存储

MyISAM会将表存储在两个文件中：数据文件（.MYD）和索引文件（.MYI）。

#### MyISAM特性

* 加锁与并发
    MyISAM对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。
* 修复
    对于MyISAM表，mysql可以手工或者自动执行检查和修复操作，但这里说的修复和事务恢复及崩溃修复是不同的概念。执行表的修复可能导致一些数据丢失，而且修复操作是非常慢的。
* 索引特性
    对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。MyISAM也支持全文索引，这时一种基于分词创建的索引，可以支持复杂的查询。
* 延迟更新索引键（Delayed Key Write）
    创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式可以极大的提升写入性能，但是在数据库或主机崩溃时会造成索引损坏，需要执行修复操作。
