---
title: 10.复制.md
date: 2021-07-31 21:44:59
tags: [mysql]
categories:
- 技术博客
- 原创
---


MySQL内建的复制功能是构建基于MySQL的大规模，高性能应用的基础，这类应用使用所谓的“水平拓展”的架构。
我们可以通过为服务器配置一个或多个备库的方式来进行数据同步。
复制功能不仅有利于构建高性能的应用，同时也是高可用性，可拓展性，灾难恢复，备份以及数据仓库等工作的基础。

## 复制概述
复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。

MySQL支持两种复制方式：`基于行的复制` 和 `基于语句的复制`。这两种方式都是通过在主库上记录二进制日志，在备库上重放日志的方式来实现异步的数据复制。这意味着，在同一时间点备库上的数据可能与主库存在不一致，并且无法保证主备之间的延迟。一些大的语句可能导致备库产生几秒，几分钟甚至几个小时的延迟。

MySQL复制大部分是向后兼容的。新版本的服务器可以作为老版本服务器的备库，但反过来，将老版本作为新版本服务器的备库通常是不可行的，因为它可能无法解析新版本所采用的特性或语法，另外所使用的二进制文件的格式也可能不相同。

复制通常不会增加主库的开销，主要是通过二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这点开销也是必要的。

通过复制可以将读操作指向备库来获得更好的拓展，但对于写操作，除非设计得当，否则并不适合通过复制来拓展写操作。在一主多备的架构中，写操作会被执行多次，这时候整个系统的性能取决于写入最慢的那部分。

### 复制解决的问题
1. 数据分布
    MySQL复制通常不会对带宽造成很大的压力，但在5.1版本引入的基于行的复制会比传统的基于语句的复制模式的带宽压力更大。你可以随意的停止或开始复制，并在不同的地理位置来分布数据备份，例如不同的数据中心，及时在不稳定的网络环境下，远程复制也可以工作，但如果为了保持很低的复制延迟，最好有一个稳定的，低延迟连接。
2. 负载均衡
    通过MySQL复制可以将读操作分布到多个服务器上，实现对读密集型应用的优化，并且实现很方便，通过简单的代码修改就能实现基本的负载均衡。对于小规模应用，可以简单的对机器名作硬编码或使用DNS轮询。
3. 备份
    对于备份来说，复制是一项很有意义的技术补充，但复制既不是备份也不能够取代备份。
4. 高可用性和故障切换
    复制能够帮助应用程序避免MySQL单点失败，一个包含复制的设计良好的故障切换系统能够显著的缩短宕机时间。
5. MySQL升级测试
    这种做法比较普遍，使用一个更高版本的MySQL作为备库，保证在升级全部实例前，查询能够在备库按照预期执行。

### 复制如何工作
1. 在主库上把数据更改记录到二进制日志（Binary Log）中（这些记录被称为二进制日志事件）
2. 备库将主库的日志复制到自己的中继日志（Relay Log）中
3. 备库读取中继日志中的事件，将其重放到备库数据之上

![MySQL复制如何工作](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1627741961_20210731220708454_1550510630.png)


## 复制的原理
### 基于语句的复制
基于语句的复制模式下，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库执行过的SQL再执行一遍。

这种方式好处是实现简单，二进制日志里的事件更加紧凑，所以相对而言，基于语句的模式不会使用太多的带宽。

但事实上基于语句的方式可能并不如其看起来那么便利。因为主库上的数据更新除执行的语句外，可能还依赖于其他因素。例如同一条SQL在主库和备库上执行的时间可能稍微或很有不同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳，再比如使用了 CURRENT_USER() 函数的语句。

另一个问题是，更新必须是串行的。这需要更多的锁。

### 基于行的复制
这种方式会将实际数据记录在二进制日志中。其最大的好处是可以正确的复制每一行，一些语句可以被更加有效的复制。


### 基于行或基于语句：哪种更优？
理论上，基于行的复制模式整体上更优，并且在实际应用中也适用于大多数场景。

- 基于语句的复制的优点：
    当主备的模式不同时，逻辑复制能够在多种情况下工作。基于语句的方式执行复制的过程基本上就是执行SQL语句，这意味着所有在服务器上发生的变更都以一种容易理解的方式运行。
- 基于语句的复制的缺点：
    很多情况下，通过语句的模式无法正确的复制，几乎每一个安装的备库都会至少碰到一次。事实上，对于存储过程，触发器以及一些其他的语句的复制在5.0和5.1的一系列版本中存在大量的Bug。这些语句的复制方式已经被修改了很多次，以使其更好的工作。
- 基于行的复制模式的优点：
    几乎没有基于行的复制模式无法处理的场景。对于所有的SQL构造，触发器，存储过程等都能正确的执行。只是当你试图做一些诸如在备库修改表的schema这样的事情时才可能导致复制失败。这种方式同样可能减少锁的使用，因为它并不要求这种强串行化是可重复的。基于行的复制会记录数据的变更，因此在二进制日志中记录的都是实际上在主库上发生了变化的数据。
- 基于行的复制模式的缺点：
    由于语句并没有在日志里记录，因此无法判断执行了哪些SQL，除了需要知道行的变化外，这在很多情况下也很重要。

### 发送复制事件到其他备库
![将复制事件传递到更多的备库](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1627741964_20210731222501407_598555486.png)

主库将数据更新事件写入二进制日志，第一个备库提取并执行这个事件。
这时候一个事件的生命周期应该已经结束了，但由于设置了 log_slave_updates，备库会将这个事件写到它自己的二进制日志中。这样第二个备库就可以将事件提取到它的中继日志中并执行。这意味着作为源服务器的主库可以将其数据变化传递给没有与其直接相连的备库上。默认情况下这个选项是被打开的，这样在连接到备库时就不需要重启服务器。

### 复制过滤器
复制过滤器允许你仅复制服务器上的一部分数据。

两种复制过滤方式：在主库上过滤记录到二进制日志中的事件，以及在备库上过滤记录到中继日志的事件。


## 复制拓扑
可以在任意个主库和备库之间建立复制，只有一个限制： **每一个备库只能有一个主库**。

记住下面的基本原则：

1. 一个MySQL备库实例只能有一个主库
2. 每个备库必须有一个唯一的服务器ID
3. 一个主库可以有多个备库（或者相应的，一个备库可以有多个兄弟备库）
4. 如果打开了 `log_slave_updates`选项，一个备库可以把其他主库上的数据变化传播到其他备库

### 一主库多备库
事实上，一主多备的结构和基本配置(一主一备)差不多简单，因为备库之间根本没有交互，他们仅仅是连接到同一个主库。

![一主多备结构](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1627824220_20210801094947879_626877968.png)


在有少量写和大量读时，这种配置是非常有用的。可以把多分摊到多个备库上，直到备库给主库造成了太大的负担，或者主备之间的带宽成为瓶颈为止。

尽管这是非常简单的拓扑结构，但它非常灵活，能满足多种需求。

- 为不同的角色使用不同的备库（例如添加不同的索引或使用不同的引擎存储）
- 把一台备库当作待用的主库，除了复制没有其他数据传输
- 将一台备库放到远程数据中心，用作灾难恢复
- 延迟一个或多个备库，以备灾难恢复
- 使用其中一个备库，作为备份，培训，开发或者测试使用服务器

### 主动-主动模式下的主-主复制
`主-主复制`也叫双向主复制或双向复制，包含两台服务器，每一个都被配置成对方的主库和备库。

![主-主复制](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1627824221_20210801100452407_1981807098.png)

这种模式通常用于特殊的目的，一个可能的应用场景是两个处于不同地理位置的办公室，并且都需要一份可写的数据拷贝。

这种配置最大的问题是如何解决冲突，两个可写的互主服务器导致的问题非常多。通常发生在两台服务器同时修改一行记录，或者同时在两台服务器上向一个包含auto_inncrement列的表里插入数据。

> MySQL不支持多主库复制
> 多主库复制特指一个备库有多个主库。MySQL不支持如图所示的结构。
> ![](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1627824221_20210801100909726_2003888296.png)


### 主动-被动模式下的主-主复制
这是前面描述的主-主结构的变体，它能够避免我们之前讨论的问题，这也是搭建容错性和高可用性系统的非常强大的方式，主要区别在于其中一台服务器是只读的被动服务器。

![主动-被动模式下的主-主复制](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1627824221_20210801101119168_586024395.png)

这种方式使得反复切换主动和被动服务器非常方便，因为服务器的配置是对称的。这使得故障转移和故障恢复很容易。它也可以让你在不关闭服务器的情况下执行维护，优化表，升级操作系统或其他任务。

如何配置主-主服务器对，在两台服务器上执行如下设置后，会使其拥有对称的设置：

1. 确保两台服务器上有相同的数据
2. 启用二进制日志，选择唯一的服务器ID，并创建复制账号
3. 启用备库更新的日志记录，后面将会看到，这是故障转移和故障恢复的关键
4. 把被动服务器配置成只读，防止可能与主动服务器上的更新产生冲突，这一点是可选的
5. 启动每个服务器的MySQL实例
6. 将每个主库设置成对方的备库，使用新创建的二进制日志开始工作。

### 拥有备库的主-主结构
![拥有备库的主-主结构](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1627824221_20210801103108851_1328972761.png)

这种配置的优点是增加了冗余，对于不同地理位置的复制拓扑，能够消除站点单点失效的问题。也可以像平常一样，将读操作分配到备库上。

### 环形复制
环形结构可以有三个或更多的主库。每个服务器都是在它之前的服务器的备库，是在它之后的服务器的主库。这种结构称为**环形复制**。

![环形复制拓扑](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1627824221_20210801184122956_1212643047.png)

环形结构没有双主结构的一些优点，例如对称配置和简单的故障转移，并且完全依赖于环上每一个可用的节点，这大大增加了整个系统失效的几率。如果从环中移除一个节点，这个节点发起的事件就会陷入无限循环：他们将永远绕着服务器链循环。因为唯一可以根据服务器ID将其过滤的服务器是创建这个事件的服务器。

### 主库，分发主库以及备库
当备库足够多时，会对主库造成很大的负担。每个备库都会在主库上创建一个线程，并执行 binlog dump命令。该命令会读取二进制日志文件中的数据并将其发送给备库，每个备库都会重复这样的工作，它们并不会共享binlog dump的资源。

因此如果需要多个备库，一个好办法时从主库移除负载并使用分发主库。分发主库事实上也是一个备库，它的唯一目的是提取和提供主库的二进制日志。多个备库连接到分发主库，这使原来的主库摆脱了负担。为了避免在分发主库上做实际的查询，可以将它的表修改为blackhole存储引擎。

![一个主库，一个分发主库和多个备库](https://img-vnote-1251075307.cos.ap-beijing.myqcloud.com/1627824222_20210801184859755_1530755458.png)

### 树或金字塔形
如果正在将主库复制到大量的备库中，不管是把数据分发到不同的地方，还是提供更高的读性能，使用金字塔结构都能更好的管理。

这种设计的好处是减轻了主库的负担。缺点是中间层出现的任何错误都会影响到多个服务器。如果每个备库和主库直接相连就不会存在这样的问题。同样，中间层越多，处理故障会更困难，更复杂。