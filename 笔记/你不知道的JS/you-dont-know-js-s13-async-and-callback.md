---
title: 学习笔记-你不知道的js-异步和回调
date: 2016-12-25 21:46:52
tags: [js]
categories:
- 学习笔记
- 你不知道的js
---

# 异步
## 异步控制台
并没有什么规范或一组需求指定 `console.*` 方法族如何工作，它们不是JavaScript正式的一部分，而是由宿主环境添加到JavaScript中的。

因此不同的浏览器和宿主环境可以按照自己的意愿来实现，有时候这会引起混淆。

需要注意的是，在某些条件下，某些浏览器的console.log()并不会把传入的内容立刻输出，出现这种情况的主要原因是，在许多程序中，I/O是非常低效的，所以浏览器在后台异步处理控制台I/O能够提高性能，这时用户可能根本意识不到其发生。

如果遇到这种少见的情况，最好的选择是在JavaScript调试器中使用断点，而不要依赖控制台输出。

## 事件循环

Javascript引擎并没有时间的概念，只是一个按需执行javascript任意代码片段的环境。“事件”调度总是由包含它的环境运行。

什么是事件循环，先通过一段伪代码了解下：

```js
//eventLoop是一个用作队列的数组
var eventLoop = [];
var event ;
while(true){
	if(eventLoop.length > 0){
		event = eventLoop.shift();
		try{
			event();
		}catch(){
			reportError(err);
		}
	}
}
```

这是一个极度精简的代码，用来说明概念。
有一个用while循环实现的持续运行的循环，循环的每一轮称为一个tick。对每个tick而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这些事件就是你的回调函数。

`setTimeout()`并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样在未来的某个tick会摘下执行这个回调。

如果这时候事件循环中已经有20个项目了怎么办？你的回调就会**等待**。它得排到其他项目后面--通常没有抢占方式支持直接将其排到队首。这也解释了为什么`setTimeout()`定时器的精度可能不高。

## 完整运行
由于JavaScript的单线程特性，函数中的代码具有原子性。

## 协作

考虑一个需要遍历很长的结果列表进行值转换的ajax响应处理函数：
```js
var res = [];
function response(data){
	res = res.concat(data.map(function(val){
		return val * 2;
	}));
}
```
如果有1000万条记录的话，就可能需要运行相当一段时间了。这样，页面上的其他代码都不能运行，包括不能有其他的response()调用或UI刷新，甚至是像滚动，输入，按钮点击这样的用户事件。这是相当痛苦的。
这里给出一个非常简单的方法：
```js
var res = [];
function response(data){
	var chunk - data.splice(0,1000);
	res = res.concat(chunk.map(function(val){
		return val * 2;
	}));

	if(data.length > 0){
		setTimeout(function(){
			response(data);
		},0);
	}
}
```
我们把数据集合放在最多包含1000条项目的块中。这样我们就确保了“进程”运行时间很短，即使这意味着需要更多的后续“进程”，因为事件循环队列的交替运行会提高站点的响应。
当然，我们并没有协调这些“进程”的顺序，所以结果的顺序是不可预测的。

> 严格来说，setTimeout(...,0)并不直接把项目插入到事件循环队列。定时器会在有机会的时候插入事件。举例来说，两个连续的setTimeout(...,0)调用不能保证会严格按照调用顺序处理，所以各种情况都有可能出现，比如定时器漂移，在这种情况下，这些事件的顺序就不可预测。在Nodejs中，类似的方法是process.nextTick()。尽管它们使用方便（通常性能也很高），但并没有（至少到目前为止）直接的方法可以适应所有环境来确保异步事件的顺序。


## 任务
在ES6中，有一个新的概念建立在事件循环队列之上，叫做“任务队列”。这个概念给搭建带来的最大影响可能是Promise的异步特性。

我认为对于任务队列最好的理解就是，它是挂在事件循环队列的每个tick之后的一个队列，在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick的任务队列末尾添加一个任务。

> 注：这里说的这个“任务队列”的概念，有些人也会用“宏任务”和“微任务”来区分，其实质是一样的。宏任务即为事件循环队列，微任务就是上面所说的任务队列这个概念。
> 在目前的nodejs中，宏任务包括：setTimeout，setInterval，setImmediate，I/O
> 微任务包括：process.nextTick，promise， Object.observe
> 详细可参照[这篇文章](https://coolcao.com/2016/12/22/node-js-event-loop/)


# 回调
## 回调地狱
```js
listen("click", function handler(evt) {
  setTimeout(function request() {
    ajax("http://some.url.1", function response(text) {
      if (text == "hello") {
        handler();
      } else if (text == "world") {
        request();
      }
    });
  }, 500);
});

```

你很可能非常熟悉这样的代码，这里我们得到了三个函数嵌套在一起构成的链，其中每个函数代表异步任务中的一个步骤。

这种代码常常被称为“回调地狱”。

## 信任问题
但回调地狱还不是回调最大的问题，**回调最大的问题是控制反转，它会导致信任链的完全断裂。**


## 小结
回调函数是JavaScript异步的基本单元，但是随着JavaScript越来越成熟，对于异步编程领域的发展，回调已经不够用了。

第一，大脑对于事情的计划方式是线性的，阻塞的，单线程的语义，但是回调表达异步流程的方式是非线性的，非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致bug。

我们需要一种更同步，更顺序，更阻塞的方式来表达异步，就像我们的大脑一样。

第二，也是更重要的一点，回调会收到控制反转的影响，因为回调暗中把控制权交给第三方（通常是不受你控制的第三方工具）来调用你代码中的回调，这种控制转移导致一些列麻烦的信任问题，比如回调被调用的次数是否会超出预期等。

可以发明一些特定逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更笨重，更难以维护的代码，并且缺少足够的保护，其中的损害要直到你受到bug的影响才会被发现。

我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调，这一方案都应可以复用，且没有重复代码的开销。

我们需要比回调更好的机制。到目前为止，回调提供了很好的服务，但是未来的JavaScript需要更高级，功能更强大的异步机制。
