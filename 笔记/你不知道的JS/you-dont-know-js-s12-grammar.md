---
title: 学习笔记-你不知道的js-语法
date: 2016-12-14 22:35:28
tags: [js]
categories:
- 学习笔记
- 你不知道的js
---

## 语句和表达式
--------
### 语句的结果值
语句都有一个结果值，获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示执行的最后一条语句的结果值。

以赋值表达式`var b=1;`为例，其结果值是赋给b的值1，但 **规范定义var的结果值是undefined** 。如果在控制台中输入`var b=1;`会得到结果值undefined，而非42。

但我们在代码中是没有办法获得这个结果值的。具体解决办法比较复杂，首先得弄清除为什么要获得语句的结果值。

<!--more-->

先来看看其他语句的结果值。比如代码块`{..}`的结果值是其最后一个语句/表达式的结果值。
例如：

```js
var b;
if(true){
    b = 1 + 1;
}
```
在控制台输入以上代码会显示2,即最后一个表达式`b = 1 + 1`的结果值。

**代码块的结果值就如同一个隐式的返回，即返回最后一个语句的结果值。**

但是下面代码无法运行：

```js
var a,b;
a = if(true){
    b = 1 + 1;
}
```

因为 **语法不允许我们获得语句的结果值并将其赋值给另一个变量**

那如何从能或得语句的结果值呢？可以使用eval(..)，但是并不推荐使用eval(..)这个操作，因此，略过。

在ES7有一个“do表达式”的提案，类似下面这样：

```js
var a,b;
a = do {
    if(true){
        b = 1 + 1;
    }
}
console.log(a); //2
```

上面例子中，do表达式执行一个代码块，包含一个或多个语句，并返回其中最后一个语句的结果值，然后赋值给变量a。

### 表达式的副作用
大多数表达式是没有副作用的，最常见的有副作用的表达式是函数调用。

#### 函数

最常见有副作用的表达式是函数调用：

```js
function foo(){
    a = a + 1;
}
var a = 1;
foo();  //结果值：undefined，副作用：a的值被改变
```

函数如果有return，则结果值是其return的值，如果没有，那么结果值是undefined。

### 递增/递减运算符

递增运算符`++`和递减运算符`--`都是一元运算符，他们既可以用在操作数之前，也可以用在操作数之后。
`++`在前面时，如 `++a` ，它的副作用（将a递增）产生在表达式返回结果值之前，而`a++`的副作用则产生在之后。

```js
var a = 42;
var b = a++;

console.log(a);	// 43
console.log(b);	// 42
```
> 这里即使 `var b = (a++)`将a++加上括号，表达式a++的返回值也是一样的。

```js
var a = 42;
var b = ++a;

console.log(a);	// 43
console.log(b);	// 43
```

> ++a++ 会产生ReferenceError错误，因为运算符需要将产生的副作用赋值给一个变量。以 ++a++ 为例，它首先执行 a++ ，返回2,然后执行 2++ ，这时会产生ReferenceError错误，因为， ++ 无法直接在 2 这样的值上产生副作用。
>

### 赋值运算符 =

```js
var a;
a = 42;
a;
```

a = 42 中的 = 运算符看起来没有什么副作用，实际上它的结果值是 42，它的副作用是将42赋值给a。

多个赋值语句串联时，赋值表达式的结果值就能派上用场了。

```js
var a,b,c;
a = b = c = 42;
```

这里 c = 42（副作用是将c赋值42） 的结果值是42，然后 b = 42（副作用是将b赋值42） 的结果值也是 42，最后是 a = 42(副作用是将a赋值42)。

> 链式赋值常常被误用，例如 var a = b = 42，看似和上面例子差不多，其实不是。如果变量b没有在作用域中像 var b这样声明过，则 var a = b = 42 不会对变量b进行声明。在严格模式下会产生错误，或者无意中会创建一个全局变量b。


### 上下文规则 
#### 大括号{}
下面两种情况会用到大括号{}:
##### 1.对象常量
用大括号定义对象常量

```js
var obj = {
    name:'coolcao',
    age:23
}
```

##### 2.代码块
###### 标签
```js
{  
	foo: bar()
}
```
{..}在这里是一个代码块，在JavaScript中并不常见，但语法上是合法的，特别是和let(块作用域)在一起使用时非常有用。

foo:bar() 叫做标签语句，foo是语句bar()的标签。可以用来进行代码跳转。

虽然JavaScript不支持goto跳转，但在循环上可以使用continue和break进行循环的跳转。

```js
// 标签为foo的循环
foo: for (var i = 0; i < 4; i++) {
  for (var j = 0; j < 4; j++) {
    // 如果j和i相等，继续外层循环
    if (j == i) {
      // 跳转到foo的下一个循环
      continue foo;
    }
    // 跳过奇数结果
    if ((j * i) % 2 == 1) {
      // 继续内层循环(没有标签的)
      continue;
    }
    console.log(i, j);
  }
}
/**
1 0
2 0
2 1
3 0
3 2
*/
```

标签也能用于非循环代码块，但只有 break 才可以。

```js
// 标签为bar的代码块
function foo() {
  bar: {
    console.log("Hello");
    break bar;
    console.log("never runs");
  }
}
console.log("World");
foo();
// Hello
// World
```

** 带标签的循环 / 代码块十分少见，也不建议使用。如果非得要用，那么一定要写好注释。**
###### 代码块强制类型转换
代码块还有一个坑：
```js
[] + {};    //"[object Object]"
{} + [];    // 0
```

第一行代码中，{}出现在+运算符之后，因此它被当作一个值（空对象）来处理。
第二行代码中，{}被当作一个独立的空代码块，不执行任何操作。所以，结果相当于是 `+ []` 的结果，是0。

###### 对象解构
ES6开始，{}也可以用于结构赋值。

```js
function getData(){
    return {
        a:42,
        b:'foo'
    }
}

var {a,b} = getData();

console.log(a,b);   //42 "foo"
```

## 运算符优先级
### 短路
```js
var a = 42;
var b = 'foo';
var c = [1,2,3];

a && b || c;
a || b && c;
```

&& 的优先级比 || 高。

因此上面的结果，a && b || c 的结果是 'foo',而 a || b && c 的结果是 42.

对 && 和 || 来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数。我们将 这种现象称为“短路”(即执行最短路径)。

### 更强的绑定
```js
a && b || c ? c || b ? a : c && b : a
```
它等同于：
```js
(a && b || c) ? (c || b) ? a : (c && b) : a
```
因为 && 运算符的优先级高于 ||，而 || 的优先级又高于 ? :。

> 注：这种细节问题，了解就好，强制记忆，因为你根本记不住，而且，在写代码时，一定不要写这种代码，会被打的。

### 关联
&&和||运算符先于? :执行，那么如果多个相同优先级的运算符同时出现，又该如何处理呢?它们的执行顺序是从左到右还是从右到左?

一般说来，运算符的关联(associativity)不是从左到右就是从右到左，这取决于组合(grouping)是从左开始还是从右开始。

从技术角度来说，因为&&运算符是左关联(||也是), 所以`a && b && c`会被处理为`(a && b) && c`。不过右关联 `a && (b && c)` 的结果也一样。

? : 是右关联，并且它的组合方式会影响返回结果。
```js
var a = true, b = false, c = true, d = true, e = false; 
a ? b : (c ? d : e); // false, 执行 a 和 b
(a ? b : c) ? d : e; // false, 执行 a, b 和 e
```

另一个右关联(组合)的例子是 = 运算符。

```js
var a, b, c;
a = b = c = 42;
```
 
它首先执行 c = 42，然后是 b = ..，最后是 a = ..。因为是右关联，所以它实际上是这样 来处理的:a = (b = (c = 42))。

### 释疑
到底是依赖优先级和关联规则来控制代码顺序，还是依赖()来控制代码顺序，这是见仁见智的问题。
如果运算符优先级/关联规则能够令代码更为简洁，就使用运算符优先级/关联规则;而如果 ( ) 有助于提高代码可读性，就使用 ( )。



## 自动分号
有时js会自动为代码补上缺失的分号，即自动分号插入（ASI）
只有在代码行末尾与换行符之间除了 **空格** 和 **注释** 之外没有别的内容时，它才会这样做。

## 错误
### 提前使用变量
ES6定义了一个新的概念：TDZ(暂时性死区)
TDZ指的是由于代码中的变量还没有初始化而不能被引用的情况。

```js
{
    a = 2;  //ReferenceError
    let a;
}
```
a = 2试图在let a初始化a之前使用该变量（其作用域在{}），这里就是a的TDZ，会产生错误。

**注意：这里使用的let，区别于var，如果是var则不会报错。因为var的作用域和let不同，以及变量提升。**

对未声明变量使用 typeof 不会产生错误，但在TDZ中却会报错：

```js
{
    typeof a;   //undefined
    typeof b;   //ReferenceError
    let b;
}
```
> 这个地方，真的是，太秀了。。。

## 函数参数
在ES6中添加了一个默认参数，这里默认参数也会出现TDZ错误：

```js
var b = 2;
function foo(a = 42,b = a + b + 5){
    //..
}
```
对于函数foo的第二个参数b，= 右边的b就是一个TDZ，所以上面这个例子会报错。

在ES6中如果参数 **被省略** 或者 **值是undefined** ，则取该参数的默认参数。

## try..finally

```js
function foo(){
    try{
        return 42;
    }
    finally{
        console.log('hello');
    }
    console.log('never runs');
}
console.log(foo());
// "hello"
// 42
```

这里return 42先执行，并将foo()函数的返回值设置为42，然后try执行完毕，接着执行finally。最后foo()函数执行完毕，console.log(foo())显示返回值。

try中的throw也是如此。

finally中的return会覆盖try和catch中的return的返回值：

```js
function baz(){
    try{
        return 42;
    }
    finally{
        //覆盖前面的 42
        return 'hello';
    }
}
baz();  //"hello"
```

## switch

```js
switch(a){
    case 2:
        //...
        break;
    case 3:
        //..
        break;
    case 4:
        //..
        break;
}
```

a和case表达式的匹配算法与`===`相同。通常case语句中的switch都是简单值。
但是有些时候，可能需要通过强制类型转换来进行匹配，这时候需要做一些变换：

```js
var a = '1';
switch(true){
    case a == 1:
        //..
        break;
    case a == 2:
        //..
        break;
    default:
        //..
        break;
}
```

除简单值以外，case 中还可以出现各种表达式，它会将表达式的结果值和 true 进行比较。 因为 a == 42 的结果为 true，所以条件成立。

尽管可以使用 `==`，但 switch 中 true 和 true 之间仍然是严格相等比较。即如果 case 表达 式的结果为真值，但不是严格意义上的 true(参见第 4 章)，则条件不成立。所以，在这 里使用 || 和 && 等逻辑运算符就很容易掉进坑里:

```js
var a = "hello world";
var b = 10;
switch (true) {
  case a || b == 10:
    // 永远执行不到这里
    break;
  default:
    console.log("Oops");
}
// Oops
```
 

因为(a || b == 10)的结果是"hello world"而非true，所以严格相等比较不成立。此时 可以通过强制表达式返回 true 或 false，如 `case !!(a || b == 10):`(参见第 4 章)。